App Entwurf FreezeTrack

ğŸ“¦ Projekt: TK-Bestands-App mit QR-Scans

ğŸ¯ Ziel

Eine ultra-einfache, webbasierte App (PWA), die Ã¼ber die Smartphone-Kamera QR-Codes scannt, TiefkÃ¼hlware einlagert/entnimmt, MHD automatisch berechnet, BestÃ¤nde anzeigt und optional Etiketten druckt.
Fokus: Scan â†’ Piep â†’ Fertig. Minimaler Aufwand, maximale Benutzbarkeit.

â¸»

âš™ï¸ Technik-Stack
	â€¢	Frontend: Vanilla JS / oder React (wahlweise)
	â€¢	PWA: Manifest + Service Worker â†’ offlinefÃ¤hig, installierbar auf iPhone
	â€¢	Scanner: @zxing/browser (fÃ¼r QR & Barcodes)
	â€¢	Storage: IndexedDB via localForage (Offline, JSON-Objekte)
	â€¢	UI: plain CSS oder Tailwind (mobilfreundlich, groÃŸe Buttons)
	â€¢	Etiketten: qrcode (QR-Generierung), JsBarcode (falls Barcodes)
Druck Ã¼ber pdf und Sticker BÃ¶gen zB von Avery -
Alternativ BT Etiketten Drucker 
	â€¢	Export/Backup: CSV/JSON-Download

â¸»

ğŸ—ƒï¸ Datenmodell (Sticker = 1 Packung)

Item {
  id: string;           // Lang-ID (z. B. "ITM:01Hâ€¦"), steht im QR
  shortId: string;      // abgeleitet, letzte 5 Zeichen
  name?: string;        // Artikelbeschreibung ("Bolognese")
  category?: string;    // optional (GemÃ¼se, Fleisch, Reste, â€¦)
  location?: string;    // Fach/Box (TK-A1, TK-B2, â€¦)
  inDate: string;       // ISO-Datum Einlagerung
  expDate: string;      // ISO-Datum MHD (berechnet oder gesetzt)
  status: "in_stock" | "used";
  notes?: string;       // optional
}

Settings

Settings {
  defaultDays: number;               // globales Standard-MHD (z. B. 180)
  categoryDefaults: Record<string, number>; // z. B. GemÃ¼se=365, Brot=90
  repeatOn: boolean;                 // Repeat-Modus an/aus
  repeatTemplate?: Partial<Item>;    // Vorlage fÃ¼r Serien
}


â¸»

ğŸ“² Workflows

1. Einlagern
	â€¢	App im Auto +1 Modus â†’ Scan = neuer Datensatz mit inDate=heute, expDate=heute+defaultDays.
	â€¢	Falls Item-ID unbekannt â†’ Edit-Overlay Ã¶ffnen (Name, Kategorie, Ort).
	â€¢	Repeat-Modus ON â†’ Felder vorausgefÃ¼llt, nur â€Speichernâ€œ klicken.

2. Entnehmen
	â€¢	App im Auto âˆ’1 Modus â†’ Scan = status="used".
	â€¢	FEFO optional: frÃ¼heste Charge zuerst (falls Mengen-Modell gewÃ¤hlt).

3. Dialog-Modus
	â€¢	Scan â†’ Overlay mit:
	â€¢	Anzeige Artikel + Bestand
	â€¢	Buttons: +1, âˆ’1, Ziffernfeld, OK
	â€¢	Quick-MHD-Tasten: Â±7 Tage, +30 Tage, Monatsende
	â€¢	Button â€UNDO letzte Aktionâ€œ

4. Bearbeiten / Labeln
	â€¢	Erstscan neuer Artikel â†’ Edit-Overlay (Name, Kategorie, Ort, Default-MHD).
	â€¢	Repeat-Modus = dieselben Werte vorausgefÃ¼llt.
	â€¢	Button â€Label druckenâ€œ â†’ QR mit ID + Kurz-ID + MHD.

â¸»

ğŸ–¥ï¸ User Interface

Hauptscreen
	â€¢	Scanner-Vorschau (Fullscreen oben)
	â€¢	Modus-Umschalter (Auto +1 / Auto âˆ’1 / Dialog)
	â€¢	UNDO-Button
	â€¢	BestandsÃ¼bersicht (Liste mit Name, Ort, MHD, Status)

Edit-Overlay
	â€¢	Felder: Name, Kategorie (Chips), Ort (Chips), Standard-MHD (Spinner), Notiz
	â€¢	Checkbox â€Repeat-Modusâ€œ
	â€¢	Buttons: [Speichern] [Abbrechen] [Label drucken]

Listen
	â€¢	Lagerbestand (nur status="in_stock")
	â€¢	Warnungen (bald fÃ¤llig â‰¤14 Tage, abgelaufen rot)
	â€¢	Export (CSV/JSON)

â¸»

ğŸ–¨ï¸ Etiketten
	â€¢	QR-Inhalt: ITM:<UUID/ULID>
	â€¢	Human-readable: Kurz-ID, Name (falls vorhanden), MHD-Zeile (zum Handschreiben)
	â€¢	GrÃ¶ÃŸe: ~20â€“24 mm KantenlÃ¤nge, kontraststark
	â€¢	Material: gefrierfeste PP/Polyester-Etiketten mit TK-Kleber

Zwei Modi:
	1.	Vorproduzierte Sticker-BÃ¶gen (UUID/ULID generiert)
	2.	Ad-hoc Druck Ã¼ber BT-Drucker (Brother P-Touch, Niimbot, Jadens C10)

â¸»

âœ… To-Do Liste

Basis
	â€¢	Projekt scaffolden (Vite oder plain HTML/JS)
	â€¢	PWA manifest + Service Worker
	â€¢	Scanner mit @zxing/browser einbinden
	â€¢	IndexedDB mit localForage
	â€¢	Item-Datenmodell implementieren
	â€¢	Turbo-Modi (Auto +1 / Auto âˆ’1 / Dialog)
	â€¢	Edit-Overlay mit Repeat-Modus
	â€¢	Standard-MHD-Berechnung implementieren
	â€¢	UNDO letzte Aktion

Komfort
	â€¢	Kategorien mit eigenen Default-MHDs
	â€¢	Quick-MHD-Tasten im Dialog
	â€¢	Autocomplete bei Namen
	â€¢	Filter: abgelaufen, bald fÃ¤llig, nach Ort

Extras
	â€¢	CSV/JSON Export & Import
	â€¢	Labeldruck-Funktion mit QR + Kurz-ID + MHD
	â€¢	BT-Druckeranbindung (Brother/ESC-P, Hersteller-App API prÃ¼fen)
	â€¢	Optional: Multi-Device-Sync via Supabase/Firestore

â¸»

ğŸš€

Genau ğŸ‘ â€“ das ist sogar noch einfacher und entspricht dem, was viele professionelle Lager-Apps machen:
	â€¢	Ein Scan = Identifikation
	â€¢	Danach nur ein kleines Overlay: +1 | âˆ’1 | Ziffernfeld (Multiplikator).
	â€¢	Alles andere lÃ¤uft automatisch.

â¸»

Vorteile dieses Ansatzes
	â€¢	Nur 1 Scan pro Vorgang (nicht zwei).
	â€¢	Keine Aktions-QRs nÃ¶tig (spart Platz & Vorbereitung).
	â€¢	Intuitiv: jeder kennt + / âˆ’ und Zahlen-Tasten.
	â€¢	Schneller fÃ¼r Serien: du scannst denselben Artikel mehrfach, die Tastatur bleibt offen â†’ direkt +5 eingeben.
	â€¢	Flexibel: du kannst auch Sondermengen eingeben (âˆ’7 fÃ¼r groÃŸe Entnahme).

â¸»

So sÃ¤he der Workflow aus
	1.	Scannen
	â€¢	Kamera scannt den QR (z. B. ITM:7XQ9F).
	â€¢	App zeigt sofort ein Overlay:

Artikel 7XQ9F (Bestand: 3)
[ âˆ’ ]   0   [ + ]
Menge: ____
[OK]


	â€¢	Buttons fÃ¼r âˆ’1, +1, Zahlentasten.

	2.	Aktion wÃ¤hlen
	â€¢	Tippe + â†’ sofort Bestand hoch.
	â€¢	Tippe âˆ’ â†’ sofort runter.
	â€¢	Tippe Zahl ein (z. B. 5) + OK â†’ Bestand angepasst.
	3.	Feedback
	â€¢	GrÃ¼n flashen bei Einlagern, Rot bei Entnahme.
	â€¢	Kurzer Ton + Haptik, damit du nicht aufs Display schauen musst.
	4.	Fertig / NÃ¤chster Artikel
	â€¢	Overlay bleibt 2â€“3 Sekunden offen â†’ du kannst Serien-Mengen machen.
	â€¢	Danach automatisch zurÃ¼ck in den Scanner.

â¸»

Optional: Turbo-Modi
	â€¢	â€Schnell-Scan-Modusâ€œ: jedes Scannen zÃ¤hlt automatisch +1 (fÃ¼r Einfrieren groÃŸer Mengen). Minus dann per Handkorrektur.
	â€¢	â€Entnahme-Modusâ€œ: jedes Scannen âˆ’1.

â¸»

Umsetzung (technisch super simpel)
	â€¢	Du brauchst nur:
	â€¢	Scanner (@zxing/browser fÃ¼r QR/Barcode).
	â€¢	Overlay-UI mit drei Buttons und kleinem Nummernfeld.
	â€¢	Bestandsdatenbank (IndexedDB/localForage).
	â€¢	Kein zweites QR-Set, keine komplexen Logiken.

â¸»

ğŸ‘‰ Damit beantwortest du die Kernfrage: Schnelligkeit vs. FlexibilitÃ¤t.
	â€¢	Variante mit Aktions-QRs = 2 Scans, null Tippen.
	â€¢	Variante mit + / âˆ’ UI = 1 Scan + 1 Klick (oder Zahl).

â¸»

Willst du, dass ich dir den bestehenden Beispielcode direkt so umbaue, dass nach jedem Scan dieses + / âˆ’ / Zahl-Overlay aufpoppt? Dann hÃ¤ttest du einen sofort testbaren Prototyp fÃ¼r deinen TK-Workflow.

Top â€“ dann lÃ¶sen wir MHD komplett â€ohne Tippenâ€œ per Standard-Haltbarkeit. Hier ist ein schlanker Plan + drop-in-Code, der zu unseren drei Turbo-Modi passt.

Wieâ€™s funktioniert (einfach)
	â€¢	Globale Standard-MHD (Tage): z. B. 180 Tage fÃ¼r TK.
	â€¢	Optional: Artikel-Override (z. B. â€Hackfleisch: 90 Tageâ€œ) oder Kategorie-Defaults (GemÃ¼se 365, Fleisch 180, Brot 90).
	â€¢	Beim Einlagern (+1) berechnet die App automatisch MHD = today + defaultDays.
	â€¢	Gleiches MHD am selben Tag? â†’ gleiche Charge (Batch) wird erhÃ¶ht.
	â€¢	Anderes MHD? â†’ neue Charge automatisch.

Mini-Korrektur ohne Tippen (falls nÃ¶tig)

Im Dialog-Modus zeigen wir drei Quick-Tasten:
	â€¢	Â±7 Tage, +30 Tage, Monatsende
und einen Button â€Heute als Produktionsdatumâ€œ (falls du Ware am Folgetag einsortierst â€“ rechnet rÃ¼ckwÃ¤rts neu). Das ist 1â€“2 Taps, kein Tippen.

Datenmodell (ergÃ¤nzt)
	â€¢	items: { id, name?, defaultDays? , category? , locationId? }
	â€¢	batches: { batchId, itemId, expDate (ISO), qty }
	â€¢	stock bleibt optional (Summe der Batches).

Workflow in den Modi
	â€¢	Auto +1: Scan â†’ Item auto-anlegen (falls neu) â†’ ensureBatchFor(item, today + defaultDays) â†’ qty++.
	â€¢	Auto âˆ’1: Scan â†’ FEFO (First-Expire-First-Out): nimm Menge aus der frÃ¼hesten Charge.
	â€¢	Dialog: wie oben, plus Menge und Quick-MHD-Tasten.

UI-Einstellungen (1x konfigurieren)
	â€¢	â€Standard-MHD (Tage)â€œ global.
	â€¢	Optional: pro Artikel â€Standard-MHD Ã¼berschreibenâ€œ.
	â€¢	Schalter: â€FEFO bei Entnahmeâ€œ (an).
	â€¢	Warnungen: bald fÃ¤llig (z. B. â‰¤14 Tage), abgelaufen (rot).

â¸»

Drop-in-Code (Auszug, Vanilla JS)

Helfer fÃ¼r MHD-Berechnung

function addDays(date, days){
  const d = new Date(date); d.setDate(d.getDate()+days); 
  d.setHours(0,0,0,0); return d;
}
function endOfMonth(date){
  const d = new Date(date); d.setMonth(d.getMonth()+1, 0);
  d.setHours(0,0,0,0); return d;
}
function iso(d){ return new Date(d).toISOString().slice(0,10); } // YYYY-MM-DD

Default-Tage ermitteln

const settings = { defaultDays: 180 }; // global, per UI Ã¤nderbar

async function getDefaultDays(item){
  if (item?.defaultDays) return item.defaultDays;
  // optional: per Kategorie verfeinern
  // if (item?.category === "GemÃ¼se") return 365;
  return settings.defaultDays;
}

Charge (Batch) finden/erzeugen

// batches-Store nach itemId indexieren; hier vereinfachte Variante mit localForage-Instanz dbBatches
async function ensureBatchFor(itemId, expDateISO){
  let found=null;
  await dbBatches.iterate(b=>{
    if (b.itemId===itemId && b.expDate===expDateISO) found=b;
  });
  if (found) return found;
  const batch = { batchId: crypto.randomUUID(), itemId, expDate: expDateISO, qty: 0 };
  await dbBatches.setItem(batch.batchId, batch);
  return batch;
}

Einlagern (mit Standard-MHD)

async function storePlusOne(itemId, baseDate = new Date()){
  const item = await upsertItem({ barcode:itemId }); // aus deinem Beispiel
  const days = await getDefaultDays(item);
  const exp = iso(addDays(baseDate, days));
  const batch = await ensureBatchFor(itemId, exp);
  batch.qty += 1;
  await dbBatches.setItem(batch.batchId, batch);
  await render();
  flash("green");
}

Entnehmen (FEFO)

async function consumeMinusOne(itemId){
  const batches = [];
  await dbBatches.iterate(b=>{ if (b.itemId===itemId) batches.push(b); });
  if (!batches.length) return beepError("Kein Bestand");
  batches.sort((a,b)=> a.expDate.localeCompare(b.expDate)); // frÃ¼hestes zuerst
  for (const b of batches){
    if (b.qty>0){ b.qty -= 1; await dbBatches.setItem(b.batchId,b); break; }
  }
  await render();
  flash("red");
}

Dialog-Quick-Tasten (ohne Tippen)

let overlayState = { itemId:null, baseDate: new Date(), delta: 0 };

function overlayFor(id){
  overlayState = { itemId:id, baseDate:new Date(), delta:0 };
  // UI zeigt exp = today + defaultDays
}
function overlayAdjustDays(n){
  overlayState.baseDate = addDays(overlayState.baseDate, n);
  // UI exp neu berechnen & anzeigen
}
function overlaySetMonthEnd(){
  overlayState.baseDate = endOfMonth(new Date());
}
async function overlayConfirm(){
  const { itemId, baseDate, delta } = overlayState;
  if (delta===0) return; // nichts zu tun
  const sign = Math.sign(delta);
  const times = Math.abs(delta);
  for (let i=0;i<times;i++){
    if (sign>0) await storePlusOne(itemId, baseDate);
    else await consumeMinusOne(itemId);
  }
  closeOverlay();
}

Auto-Modi anbinden

let mode = "autoPlus"; // "autoPlus" | "autoMinus" | "dialog"

async function onScan(itemId){
  await ensureItem(itemId);
  if (mode==="autoPlus")  return storePlusOne(itemId);
  if (mode==="autoMinus") return consumeMinusOne(itemId);
  overlayFor(itemId); // Dialog
}


â¸»

Listen & Druck
	â€¢	FEFO-Pickliste: sortiere batches nach expDate â†’ zeige â€heute/7/14 Tage fÃ¤lligâ€œ.
	â€¢	Etikettendruck: QR + â€MHD: 2026-03-14â€œ mitdrucken (bei Nachdruck oder Erstetikett).
(Mit JsBarcode/QRCode wie im vorherigen Beispiel â€“ nur die MHD-Zeile ergÃ¤nzen.)

â¸»

Gute Defaults (du kannst spÃ¤ter feinjustieren)
	â€¢	Global: TK 180 Tage.
	â€¢	GemÃ¼se/Obst: 365 Tage (TK).
	â€¢	Brot/Backwaren: 90 Tage.
	â€¢	Gekochtes/Resteboxen: 120 Tage.
Du kannst das zunÃ¤chst nur global starten (am simpelsten). Wennâ€™s sitzt, ergÃ¤nzen wir pro Artikel eine eigene Zahl.

â¸»

Wenn du mÃ¶chtest, baue ich dir den vorhandenen Prototypen direkt mit:
	â€¢	Auto Â±1 / Dialog
	â€¢	Batches mit MHD
	â€¢	FEFO-Entnahme
	â€¢	Quick-Tasten Â±7 / +30 / Monatsende

Sag mir nur: Starten wir mit nur einem globalen Wert (z. B. 180) â€“ und feiner spÃ¤ter?

ğŸ‘‰



100% dâ€™accord â€“ wennâ€™s nicht in 1â€“2 Handgriffen geht, nutzt es keiner. Lass uns den Workflow radikal auf â€scannen, piep, fertigâ€œ trimmen. Hier ist ein Setup, das in der Praxis wirklich schnell ist â€“ ohne Tippen, ohne MenÃ¼s.

Der ultraschnelle Standard-Workflow

Physische Bausteine
	1.	Artikel-Sticker (QR)
â€“ Vorab A4-BÃ¶gen mit zufÃ¤lligen IDs drucken (z. B. ITM:01Hâ€¦).
â€“ Auf jedem Sticker zusÃ¤tzlich: Kurz-ID (z. B. letzte 5 Zeichen) + kleine MHD-Zeile zum handschriftlichen Datum.
â€“ Beim Einfrieren: Sticker drauf â€“ fertig.
	2.	Aktions-Pad (QR) â€“ laminiert an/ in die Truhe:

	â€¢	â€+1 Einlagernâ€œ â†’ ADD:
	â€¢	â€âˆ’1 Entnehmenâ€œ â†’ USE:
	â€¢	Mengen-Modifier: Ã—2, Ã—3, Ã—5 â†’ SETQTY:+2 (als Zusatz) oder â€zweimal scannenâ€œ
	â€¢	Orte (FÃ¤cher): SETLOC:TK-A1, TK-A2, â€¦
	â€¢	UNDO (letzte Aktion rÃ¼ckgÃ¤ngig)

Du scannst immer nur groÃŸe Kachel + Item-Sticker. Keine Tastatur, kein Suchen.

App-Logik (super simpel)
	â€¢	Die App merkt sich zwei Dinge: letzte Aktion & letzte Item-ID.
	â€¢	Reihenfolge egal:
	â€¢	Scannst du â€+1â€œ und dann Item â†’ Bestand +1.
	â€¢	Scannst du Item und dann â€âˆ’1â€œ â†’ Bestand âˆ’1.
	â€¢	Modifier/Ort kannst du davor oder danach scannen:
	â€¢	Ã—3 + Item = drei StÃ¼ck in einem Rutsch.
	â€¢	SETLOC:TK-A1 + Item = Ort gesetzt.
	â€¢	Feedback: groÃŸer Farbflash (grÃ¼n/rot), kurzer Ton, Haptik (iPhone).
	â€¢	UNDO: Scan â€UNDOâ€œ â†’ letzte Buchung rÃ¼ckgÃ¤ngig, fertig.

TÃ¤gliche Nutzung
	â€¢	Einlagern (2 Scans): +1 â†’ Item-QR. Piep.
	â€¢	Entnehmen (2 Scans): âˆ’1 â†’ Item-QR. Piep.
	â€¢	Mehrere gleiche Items (Batch): Batch +1 (Knopf in der App) aktiv â†’ nur Item-QR n-mal scannen, jedes Mal piep.
	â€¢	Ort zuweisen: SETLOC:TK-A1 â†’ Item-QR (oder im Batch einmal Ort scannen, gilt fÃ¼r alle folgenden Scans bis geÃ¤ndert).

Warum das schnell bleibt
	â€¢	Null Tippen (Namen optional/selten).
	â€¢	Zwei Scans max. pro Aktion â€“ oft sogar einer im Batch.
	â€¢	GroÃŸe, feste Ziel-QRs (Aktionen) kleben in Griffweite.
	â€¢	Item-QRs sind klein, aber robust (QR statt EAN).
	â€¢	Fehlertolerant: Reihenfolge egal, UNDO da.

Details, die es in der Praxis retten
	â€¢	StickergrÃ¶ÃŸe: QR-KantenlÃ¤nge ~20â€“24 mm; darunter Kleintext: â€Kurz-ID 7XQ9F | MHD: ____â€œ.
	â€¢	Material: gefrierfeste PP/Polyester-Etiketten, starker Gefrierkleber.
	â€¢	Visuelles System: FÃ¤cher farbcodiert (A-F) + zugehÃ¶rige SETLOC-QRs in derselben Farbe â†’ Gehirn schaltet auf Autopilot.
	â€¢	Akustik: anderes Piep fÃ¼r +/âˆ’, langer Ton bei Fehler, kurzer Doppel-Piep bei Batch-Modus.
	â€¢	â€Lieblingsartikelâ€œ (optional): Erstes Mal, wenn eine neue ID auftaucht, tippst du EINMAL auf einen groÃŸen Favoriten-Chip (â€Erbsenâ€œ, â€Beerenâ€œ, â€Boloâ€œ). Danach nie mehr. Fehlt dir das komplett? Lass es weg â€“ Namen sind nett, aber nicht nÃ¶tig fÃ¼rs ZÃ¤hlen.

Drei Nutzungsstufen (du entscheidest)
	1.	â€ZÃ¤hlen reichtâ€œ (Default)
â€“ Nur IDs, Mengen, Orte. Kein Tippen, nur Scans.
	2.	â€Leichte Namenâ€œ
â€“ Optional 6â€“8 Favoriten als groÃŸe Chips; 1-Tap beim ersten Mal.
	3.	â€Detailmodus (selten)â€œ
â€“ Pro Charge MHD oder Notiz tippen â€“ nur wenn du magst (z. B. fÃ¼r Resteverwaltung).

SonderfÃ¤lle sauber gelÃ¶st
	â€¢	Kein Sticker mehr? Scanne ADD: â†’ App zeigt â€Neue ID generiertâ€œ â†’ tippe 1Ã— â€Druckenâ€œ (falls BT-Drucker nebenan) oder klebe einen vorproduzierten Reserve-Sticker.
	â€¢	Sticker beschÃ¤digt? Kurz-ID eintippen oder Ãœbersicht Ã¶ffnen und per Kamera-Suche das Item finden (Sekundenarbeit).
	â€¢	Duplizierte IDs (versehentlich 2Ã— gleiches Label genutzt)? App meldetâ€™s, bietet â€mit bestehendem Artikel zusammenfÃ¼hrenâ€œ.

UI in 5 groÃŸen FlÃ¤chen (Daumen-Bedienung)
	â€¢	Oben Vollbild-Scanner (immer aktiv).
	â€¢	Darunter Aktions-Leiste: â€+1â€œ, â€âˆ’1â€œ, â€Batchâ€œ, â€UNDOâ€œ.
	â€¢	Ort-Chips (deine 6â€“10 FÃ¤cher).
	â€¢	Mengen-Chips: Ã—2 / Ã—3 / Ã—5.
	â€¢	Footer: Bestand-Kacheln (nur lesen), groÃŸe Suchleiste (optional).

Physisches Setup (entscheidet Ã¼ber Erfolg)
	â€¢	Aktions-Pad direkt an die Truhe (Innen-Deckel).
	â€¢	BT-Drucker (wenn genutzt) direkt daneben auf einem kleinen Regal.
	â€¢	Etiketten-BÃ¶gen griffbereit in einer KlarsichthÃ¼lle an der Truhe.
	â€¢	Filzstift (MHD) hÃ¤ngt an der Truhe.

Messbar machen (damit wir merken, obâ€™s wirklich easy ist)
	â€¢	Zielwerte:
	â€¢	Einlagern: â‰¤ 3 Sek. pro Artikel (2 Scans).
	â€¢	Entnehmen: â‰¤ 2 Sek. pro Artikel (2 Scans).
	â€¢	Fehlerrate: < 1% (UNDO fÃ¤ngt auf).
	â€¢	In der App: simple Counter â€heute gespeichert/entnommenâ€œ + â€Zeit pro Vorgangâ€œ.

â¸»

Wenn du willst, setze ich dir genau diese drei Dinge direkt um:
	1.	A4-Bogen: 80 vorproduzierte Item-QR-Sticker (mit Kurz-ID & MHD-Zeile).
	2.	A4-Aktions-Pad: +1, âˆ’1, Ã—2/Ã—3/Ã—5, UNDO, SETLOC fÃ¼r deine FÃ¤cher.
	3.	App-Einstellung: â€Zwei-Scan-Logikâ€œ, Batch-Modus, UNDO, farbiges Feedback.

Sag mir nur kurz deine Fach-Bezeichnungen (z. B. TK-A1â€¦A4, TK-B1â€¦B4) und ob du Namen/Favoriten Ã¼berhaupt willst â€“ ansonsten baue ich es im â€ZÃ¤hlen reichtâ€œ-Modus, der ist am schnellsten.

ultraschnell & simpel

Drei Modi (umschaltbar oben in der App):
	1.	Auto +1 â€“ Jeder Scan zÃ¤hlt sofort +1. (FÃ¼r Einfrieren â€“ zack zack.)
	2.	Auto âˆ’1 â€“ Jeder Scan zÃ¤hlt sofort âˆ’1. (FÃ¼r Entnahmen.)
	3.	Dialog â€“ Scan â†’ kleines Overlay mit +1, âˆ’1, Ziffernfeld â†’ OK.

Warum kein â€Ã—-Multiplikator-QRâ€œ?
Brauchen wir nicht. Deine IDs sind zufÃ¤llig; Multiplizieren per â€Ã—3â€œ-QR war nur fÃ¼r die Zwei-Scan-Variante sinnvoll. Hier reicht im Dialog die Zahl einzugeben â€“ oder du bleibst in Auto-+1 und scannst denselben Sticker n-mal (sehr schnell).

Quality-of-life:
	â€¢	UNDO: groÃŸer Button, macht den letzten Scan rÃ¼ckgÃ¤ngig.
	â€¢	Unknown ID â†’ auto-anlegen (nur ID + optional Ort; Name spÃ¤ter).
	â€¢	Haptik/Ton/Farbflash: + grÃ¼n, âˆ’ rot, Fehler gelb.
	â€¢	â€Sticky-Ortâ€œ (optional): einmal Ort wÃ¤hlen â†’ gilt, bis duâ€™s Ã¤nderst.
	â€¢	Timeout: Dialog schlieÃŸt nach 2â€“3 s automatisch; Modus bleibt.

â¸»

Logik (knackig)

let mode = "autoPlus"; // "autoPlus" | "autoMinus" | "dialog"

async function onScan(id){         // id ist z.B. "ITM:01Hâ€¦"
  await ensureItem(id);            // auto-anlegen falls neu
  if (mode === "autoPlus")  return move(id, +1), flash("green");
  if (mode === "autoMinus") return move(id, -1), flash("red");
  openOverlay(id);                 // Dialog: +1 / -1 / Zahl -> OK
}

async function overlayConfirm(id, delta){ // delta kann Â±1 oder Â±N sein
  await move(id, delta);
  flash(delta>0 ? "green" : "red");
}

function undoLast(){ /* letzte move rÃ¼ckgÃ¤ngig machen */ }


â¸»

Bedienung in der Praxis
	â€¢	Einfrieren (Serien): Modus Auto +1, jeden Sticker einmal scannen â†’ piep, fertig.
	â€¢	Entnehmen: Modus Auto âˆ’1, einmal scannen â†’ piep, fertig.
	â€¢	Sondermengen: Modus Dialog, scannen â†’ Zahl tippen â†’ OK.

Das ist wirklich â€Scan â†’ piep â†’ weiterâ€œ. Keine Aktions-QRs, keine MenÃ¼s.

â¸»

NÃ¤chste kleine Extras (wenn du magst)
	â€¢	â€Doppeltipp = Â±5â€œ auf dem Plus/Minus im Dialog.
	â€¢	MHD-Hinweis: nach erstem +1 auf neue ID optional Datum eintippen (oder ignorieren).
	â€¢	Schnellfilter: â€unter Minimumâ€œ, â€bald fÃ¤lligâ€œ, â€nach Ortâ€œ â€“ nur lesen, kein Tippen nÃ¶tig.

Wenn du willst, passe ich dir den Beispielcode direkt auf diese drei Modi + Overlay + UNDO an â€“ dann kannst du ihn sofort im Browser testen (PWA, offline, iPhone-Kamera ready).



Absolut â€“ â€œScan â†’ ggf. kurz benennen â†’ weiterâ€ + Repeat-Modus ist genau der Sweet-Spot. Hier ist ein schlanker, praxistauglicher Plan inkl. Drop-in-Logik:

Ziel
	â€¢	Nach dem Scan nur dann editieren, wenn nÃ¶tig (neu/unnÃ¼tz benannt).
	â€¢	Edit-Overlay: 3â€“5 Felder, groÃŸe Buttons, in 5â€“10 Sek. erledigt.
	â€¢	Repeat-Modus: â€Vorherige Eingaben vorausfÃ¼llenâ€œ fÃ¼r Serien (z. B. viele Beutel Bolognese).

â¸»

UX-Flow
	1.	Scan
	â€¢	Wenn neu ODER Name fehlt â†’ Edit-Overlay Ã¶ffnen.
	â€¢	Wenn bekannt â†’ normaler Turbo-Modus (Auto Â±1 / Dialog).
	2.	Edit-Overlay (Daumen-freundlich)
Felder (in dieser Reihenfolge):
	â€¢	Name (Pflicht, AutovervollstÃ¤ndigung aus â€œzuletzt verwendetâ€)
	â€¢	Kategorie (Chips: GemÃ¼se, Fleisch, Reste, Brot, â€¦) â†’ setzt optional Default-MHD
	â€¢	Ort (Chips: TK-A1, TK-A2, â€¦)
	â€¢	Standard-MHD (Tage) (kleiner Spinner; vorausgefÃ¼llt aus global/kategorie)
	â€¢	Notiz (optional, 1 Zeile)
Buttons unten: [Speichern] [Abbrechen] [Label drucken]
Option rechts oben: Repeat ON/OFF (Schalter).
	3.	Repeat-Modus
	â€¢	Wenn ON: Beim nÃ¤chsten neuen Scan sind Name/Kategorie/Ort/Default-MHD vorausgefÃ¼llt (aus â€Last Templateâ€œ) â€“ nur noch Speichern tippen (oder gleich Auto +1 ohne Edit, je nach Modus).
	â€¢	Wenn OFF: Normales Verhalten.
	4.	Schnellzugriffe
	â€¢	Langer Druck auf â€Letzter Artikelâ€œ-Badge (am unteren Rand) â†’ Edit-Overlay mit den letzten Werten Ã¶ffnen.
	â€¢	Doppeltipp im Dialog-Modus auf den Artikelnamen â†’ sofort Edit-Overlay.

â¸»

Datenmodell (ergÃ¤nzt)

Item {
  id: string;          // "ITM:â€¦"
  name?: string;
  category?: string;   // z.B. "Fleisch"
  locationId?: string; // z.B. "TK-A1"
  defaultDays?: number; // Override
  notes?: string;
  createdAt: string;
  updatedAt: string;
}

Settings {
  defaultDays: number;       // global
  categoryDefaults: Record<string, number>; // optional
  repeatTemplate?: Partial<Item>; // zuletzt gespeichertes Template
  repeatOn: boolean;
}


â¸»

Entscheidungslogik (wann Edit aufpoppt)

function shouldEditAfterScan(item, settings){
  if (!item) return true;               // neu â†’ anlegen/benennen
  if (!item.name) return true;          // unbenannt â†’ benennen
  // Optional: Shortcut-Taste â€Edit erzwungenâ€œ (z. B. Taste E)
  return false;
}


â¸»

Drop-in-Code (AuszÃ¼ge, Vanilla JS)

Zentrales Scan-Handling

let settings = {
  defaultDays: 180,
  categoryDefaults: { GemÃ¼se: 365, Fleisch: 180, Brot: 90, Reste: 120 },
  repeatOn: false,
  repeatTemplate: null
};

async function onScan(itemId){
  let item = await dbItems.getItem(itemId);
  if (!item) {
    // Neu anlegen (minimal)
    item = { id: itemId, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
    // Repeat-Template anwenden, falls aktiv
    if (settings.repeatOn && settings.repeatTemplate) {
      Object.assign(item, settings.repeatTemplate);
    }
    await dbItems.setItem(itemId, item);
  }
  if (shouldEditAfterScan(item, settings)) {
    openEditOverlay(item);  // â†’ siehe unten
  } else {
    // Sonst normaler Turbo-Modus
    if (mode === "autoPlus")  return storePlusOne(itemId);
    if (mode === "autoMinus") return consumeMinusOne(itemId);
    openDialogOverlay(itemId);
  }
}

Edit-Overlay Ã¶ffnen & vorausfÃ¼llen

function computeDefaultDaysFor(item){
  if (Number.isFinite(item.defaultDays)) return item.defaultDays;
  if (item.category && Number.isFinite(settings.categoryDefaults[item.category])) {
    return settings.categoryDefaults[item.category];
  }
  return settings.defaultDays;
}

function openEditOverlay(item){
  const el = document.getElementById('editOverlay');
  // Felder setzen
  el.querySelector('#f_name').value      = item.name || settings?.repeatTemplate?.name || '';
  el.querySelector('#f_category').value  = item.category || settings?.repeatTemplate?.category || '';
  el.querySelector('#f_location').value  = item.locationId || settings?.repeatTemplate?.locationId || '';
  el.querySelector('#f_days').value      = computeDefaultDaysFor(item);
  el.querySelector('#f_notes').value     = item.notes || '';
  el.querySelector('#repeatToggle').checked = !!settings.repeatOn;

  el.dataset.itemId = item.id;
  el.style.display = 'block';
}

Speichern + Template aktualisieren

async function saveEdit(){
  const el = document.getElementById('editOverlay');
  const id  = el.dataset.itemId;

  const updated = {
    id,
    name:       el.querySelector('#f_name').value.trim(),
    category:   el.querySelector('#f_category').value.trim() || undefined,
    locationId: el.querySelector('#f_location').value.trim() || undefined,
    defaultDays: parseInt(el.querySelector('#f_days').value, 10),
    notes:      el.querySelector('#f_notes').value.trim() || undefined,
    updatedAt:  new Date().toISOString()
  };

  const existing = await dbItems.getItem(id) || { id, createdAt: new Date().toISOString() };
  const merged = { ...existing, ...updated };
  await dbItems.setItem(id, merged);

  // Repeat-Schalter Ã¼bernehmen & Template aktualisieren
  settings.repeatOn = el.querySelector('#repeatToggle').checked;
  if (settings.repeatOn) {
    settings.repeatTemplate = {
      name: merged.name,
      category: merged.category,
      locationId: merged.locationId,
      defaultDays: merged.defaultDays
    };
    await dbSettings.setItem('repeatTemplate', settings.repeatTemplate);
    await dbSettings.setItem('repeatOn', true);
  } else {
    settings.repeatTemplate = null;
    await dbSettings.setItem('repeatOn', false);
  }

  // optional: direkt Label drucken?
  // printLabel(merged); // falls Button gedrÃ¼ckt wurde

  closeEditOverlay();
  render(); // Tabelle aktualisieren
}

UI-Schnipsel (Overlay-HTML minimal)

<div id="editOverlay" style="display:none; position:fixed; inset:0; background:#0008;">
  <div style="margin:10vh auto; max-width:520px; background:#fff; padding:16px; border-radius:12px;">
    <h3>Artikel bearbeiten</h3>
    <label>Name <input id="f_name" placeholder="z.B. Bolognese" autofocus></label>
    <label>Kategorie 
      <select id="f_category">
        <option value="">â€“</option>
        <option>GemÃ¼se</option><option>Fleisch</option><option>Brot</option><option>Reste</option>
      </select>
    </label>
    <label>Ort 
      <select id="f_location"><option>TK-A1</option><option>TK-A2</option><option>TK-B1</option><option>TK-B2</option></select>
    </label>
    <label>Standard-MHD (Tage) <input id="f_days" type="number" min="1" step="1"></label>
    <label>Notiz <input id="f_notes" placeholder="optional"></label>
    <div style="display:flex;align-items:center;gap:.5rem;margin:.5rem 0;">
      <input id="repeatToggle" type="checkbox"> <label for="repeatToggle">Repeat-Modus</label>
    </div>
    <div style="display:flex; gap:.5rem; justify-content:flex-end;">
      <button onclick="closeEditOverlay()">Abbrechen</button>
      <button onclick="saveEdit()">Speichern</button>
      <button onclick="saveEdit(); printLabelById(this.closest('#editOverlay').dataset.itemId)">Label drucken</button>
    </div>
  </div>
</div>

â€Letzten Artikelâ€œ schnell wiederverwenden

let lastScannedId = null;

async function onScan(itemId){
  lastScannedId = itemId;
  // ... (wie oben)
}

function editLast(){
  if (!lastScannedId) return;
  dbItems.getItem(lastScannedId).then(openEditOverlay);
}
// UI: ein kleiner â€Stiftâ€œ-Button neben â€zuletzt gescannt: â€¦â€œ


â¸»

Feinschliff (machtâ€™s spÃ¼rbar besser)
	â€¢	Fokus nach Ã–ffnen direkt in â€Nameâ€œ, Enter = Speichern.

Praxis-Beispiel
	â€¢	Du kochst 10 x Bolo â†’ Repeat ON, einmal â€Bolognese / Reste / TK-A2 / 120 Tageâ€œ speichern â†’ danach nur scannen (Auto +1) â€“ kein weiteres Tippen.
	â€¢	Neues Produkt â€Erbsenâ€œ â†’ erster Scan Ã¶ffnet Edit â†’ Name/Kategorie/Ort setzen â†’ fertig; danach nur noch scannen.


dir fehlt nur Ort, Status und (fÃ¼r Komfort) Defaults/Verlauf.
Du hast: Bestand, Beschreibung (Name), ID (+ Kurz-ID ableitbar), Einlagerdatum, MHD. Das reicht knapp â€“ aber zwei Dinge entscheiden die Alltagstauglichkeit:

Erst entscheiden: 1 Sticker = 1 Packung (empfohlen)

Dann brauchst du keine Mengenfelder â€“ der Bestand ist einfach die Anzahl DatensÃ¤tze.

Minimal-Schema (wirklich schlank & ausreichend)
	â€¢	id (Lang-ID im QR)
	â€¢	shortId (abgeleitet, z. B. letzte 5 Zeichen)
	â€¢	name (Artikelbeschreibung)
	â€¢	location (Fach/Box, z. B. â€TK-A2â€œ) â† fehlt noch
	â€¢	inDate (Einlagerdatum)
	â€¢	expDate (MHD)
	â€¢	status ("in_stock"/"used") â† fehlt fÃ¼r Entnahmen/UNDO
	â€¢	notes (optional, 1 Zeile)

Bestand = count(where status="in_stock").
Vorteil: Scannen = neuer Datensatz, Entnahme = Status auf â€usedâ€œ. Super robust, null Summenlogik.

Alternative: 1 ID = Artikel (SKU) mit Menge

Dann brauchst du Mengen & Chargen:
	â€¢	item (SKU) + qty (aktuelle Menge)
	â€¢	batches[{expDate, qty}] (fÃ¼r MHD/FEFO)
	â€¢	moves[{timestamp, delta}] (Verlauf fÃ¼r UNDO)

Das ist flexibler, aber komplexer. FÃ¼r deinen â€Scan-Piep-Fertigâ€œ-Ansatz ist 1 Sticker = 1 Packung einfacher.

Zwei kleine ErgÃ¤nzungen, die es spÃ¼rbar besser machen
	â€¢	Defaults: defaultDays (global oder per Kategorie) â†’ MHD wird automatisch gerechnet.
	â€¢	Verlauf (leicht): lastMove (Zeit+Aktion) â†’ UNDO ohne Kopfzerbrechen.

Fazit
	â€¢	Mit 1 Sticker = 1 Packung ist dein Set mit Ort + Status vollstÃ¤ndig und alltagstauglich.
	â€¢	Wenn du stattdessen mit Mengen arbeiten willst, brauchst du Chargen + Moves dazu.

Sag mir, welche Variante du nimmst â€“ ich passe dir den Prototyp (Felder/UI) direkt darauf an.
