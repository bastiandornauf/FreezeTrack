App Entwurf FreezeTrack

📦 Projekt: TK-Bestands-App mit QR-Scans

🎯 Ziel

Eine ultra-einfache, webbasierte App (PWA), die über die Smartphone-Kamera QR-Codes scannt, Tiefkühlware einlagert/entnimmt, MHD automatisch berechnet, Bestände anzeigt und optional Etiketten druckt.
Fokus: Scan → Piep → Fertig. Minimaler Aufwand, maximale Benutzbarkeit.

⸻

⚙️ Technik-Stack
	•	Frontend: Vanilla JS / oder React (wahlweise)
	•	PWA: Manifest + Service Worker → offlinefähig, installierbar auf iPhone
	•	Scanner: @zxing/browser (für QR & Barcodes)
	•	Storage: IndexedDB via localForage (Offline, JSON-Objekte)
	•	UI: plain CSS oder Tailwind (mobilfreundlich, große Buttons)
	•	Etiketten: qrcode (QR-Generierung), JsBarcode (falls Barcodes)
Druck über pdf und Sticker Bögen zB von Avery -
Alternativ BT Etiketten Drucker 
	•	Export/Backup: CSV/JSON-Download

⸻

🗃️ Datenmodell (Sticker = 1 Packung)

Item {
  id: string;           // Lang-ID (z. B. "ITM:01H…"), steht im QR
  shortId: string;      // abgeleitet, letzte 5 Zeichen
  name?: string;        // Artikelbeschreibung ("Bolognese")
  category?: string;    // optional (Gemüse, Fleisch, Reste, …)
  location?: string;    // Fach/Box (TK-A1, TK-B2, …)
  inDate: string;       // ISO-Datum Einlagerung
  expDate: string;      // ISO-Datum MHD (berechnet oder gesetzt)
  status: "in_stock" | "used";
  notes?: string;       // optional
}

Settings

Settings {
  defaultDays: number;               // globales Standard-MHD (z. B. 180)
  categoryDefaults: Record<string, number>; // z. B. Gemüse=365, Brot=90
  repeatOn: boolean;                 // Repeat-Modus an/aus
  repeatTemplate?: Partial<Item>;    // Vorlage für Serien
}


⸻

📲 Workflows

1. Einlagern
	•	App im Auto +1 Modus → Scan = neuer Datensatz mit inDate=heute, expDate=heute+defaultDays.
	•	Falls Item-ID unbekannt → Edit-Overlay öffnen (Name, Kategorie, Ort).
	•	Repeat-Modus ON → Felder vorausgefüllt, nur „Speichern“ klicken.

2. Entnehmen
	•	App im Auto −1 Modus → Scan = status="used".
	•	FEFO optional: früheste Charge zuerst (falls Mengen-Modell gewählt).

3. Dialog-Modus
	•	Scan → Overlay mit:
	•	Anzeige Artikel + Bestand
	•	Buttons: +1, −1, Ziffernfeld, OK
	•	Quick-MHD-Tasten: ±7 Tage, +30 Tage, Monatsende
	•	Button „UNDO letzte Aktion“

4. Bearbeiten / Labeln
	•	Erstscan neuer Artikel → Edit-Overlay (Name, Kategorie, Ort, Default-MHD).
	•	Repeat-Modus = dieselben Werte vorausgefüllt.
	•	Button „Label drucken“ → QR mit ID + Kurz-ID + MHD.

⸻

🖥️ User Interface

Hauptscreen
	•	Scanner-Vorschau (Fullscreen oben)
	•	Modus-Umschalter (Auto +1 / Auto −1 / Dialog)
	•	UNDO-Button
	•	Bestandsübersicht (Liste mit Name, Ort, MHD, Status)

Edit-Overlay
	•	Felder: Name, Kategorie (Chips), Ort (Chips), Standard-MHD (Spinner), Notiz
	•	Checkbox „Repeat-Modus“
	•	Buttons: [Speichern] [Abbrechen] [Label drucken]

Listen
	•	Lagerbestand (nur status="in_stock")
	•	Warnungen (bald fällig ≤14 Tage, abgelaufen rot)
	•	Export (CSV/JSON)

⸻

🖨️ Etiketten
	•	QR-Inhalt: ITM:<UUID/ULID>
	•	Human-readable: Kurz-ID, Name (falls vorhanden), MHD-Zeile (zum Handschreiben)
	•	Größe: ~20–24 mm Kantenlänge, kontraststark
	•	Material: gefrierfeste PP/Polyester-Etiketten mit TK-Kleber

Zwei Modi:
	1.	Vorproduzierte Sticker-Bögen (UUID/ULID generiert)
	2.	Ad-hoc Druck über BT-Drucker (Brother P-Touch, Niimbot, Jadens C10)

⸻

✅ To-Do Liste

Basis
	•	Projekt scaffolden (Vite oder plain HTML/JS)
	•	PWA manifest + Service Worker
	•	Scanner mit @zxing/browser einbinden
	•	IndexedDB mit localForage
	•	Item-Datenmodell implementieren
	•	Turbo-Modi (Auto +1 / Auto −1 / Dialog)
	•	Edit-Overlay mit Repeat-Modus
	•	Standard-MHD-Berechnung implementieren
	•	UNDO letzte Aktion

Komfort
	•	Kategorien mit eigenen Default-MHDs
	•	Quick-MHD-Tasten im Dialog
	•	Autocomplete bei Namen
	•	Filter: abgelaufen, bald fällig, nach Ort

Extras
	•	CSV/JSON Export & Import
	•	Labeldruck-Funktion mit QR + Kurz-ID + MHD
	•	BT-Druckeranbindung (Brother/ESC-P, Hersteller-App API prüfen)
	•	Optional: Multi-Device-Sync via Supabase/Firestore

⸻

🚀

Genau 👍 – das ist sogar noch einfacher und entspricht dem, was viele professionelle Lager-Apps machen:
	•	Ein Scan = Identifikation
	•	Danach nur ein kleines Overlay: +1 | −1 | Ziffernfeld (Multiplikator).
	•	Alles andere läuft automatisch.

⸻

Vorteile dieses Ansatzes
	•	Nur 1 Scan pro Vorgang (nicht zwei).
	•	Keine Aktions-QRs nötig (spart Platz & Vorbereitung).
	•	Intuitiv: jeder kennt + / − und Zahlen-Tasten.
	•	Schneller für Serien: du scannst denselben Artikel mehrfach, die Tastatur bleibt offen → direkt +5 eingeben.
	•	Flexibel: du kannst auch Sondermengen eingeben (−7 für große Entnahme).

⸻

So sähe der Workflow aus
	1.	Scannen
	•	Kamera scannt den QR (z. B. ITM:7XQ9F).
	•	App zeigt sofort ein Overlay:

Artikel 7XQ9F (Bestand: 3)
[ − ]   0   [ + ]
Menge: ____
[OK]


	•	Buttons für −1, +1, Zahlentasten.

	2.	Aktion wählen
	•	Tippe + → sofort Bestand hoch.
	•	Tippe − → sofort runter.
	•	Tippe Zahl ein (z. B. 5) + OK → Bestand angepasst.
	3.	Feedback
	•	Grün flashen bei Einlagern, Rot bei Entnahme.
	•	Kurzer Ton + Haptik, damit du nicht aufs Display schauen musst.
	4.	Fertig / Nächster Artikel
	•	Overlay bleibt 2–3 Sekunden offen → du kannst Serien-Mengen machen.
	•	Danach automatisch zurück in den Scanner.

⸻

Optional: Turbo-Modi
	•	„Schnell-Scan-Modus“: jedes Scannen zählt automatisch +1 (für Einfrieren großer Mengen). Minus dann per Handkorrektur.
	•	„Entnahme-Modus“: jedes Scannen −1.

⸻

Umsetzung (technisch super simpel)
	•	Du brauchst nur:
	•	Scanner (@zxing/browser für QR/Barcode).
	•	Overlay-UI mit drei Buttons und kleinem Nummernfeld.
	•	Bestandsdatenbank (IndexedDB/localForage).
	•	Kein zweites QR-Set, keine komplexen Logiken.

⸻

👉 Damit beantwortest du die Kernfrage: Schnelligkeit vs. Flexibilität.
	•	Variante mit Aktions-QRs = 2 Scans, null Tippen.
	•	Variante mit + / − UI = 1 Scan + 1 Klick (oder Zahl).

⸻

Willst du, dass ich dir den bestehenden Beispielcode direkt so umbaue, dass nach jedem Scan dieses + / − / Zahl-Overlay aufpoppt? Dann hättest du einen sofort testbaren Prototyp für deinen TK-Workflow.

Top – dann lösen wir MHD komplett „ohne Tippen“ per Standard-Haltbarkeit. Hier ist ein schlanker Plan + drop-in-Code, der zu unseren drei Turbo-Modi passt.

Wie’s funktioniert (einfach)
	•	Globale Standard-MHD (Tage): z. B. 180 Tage für TK.
	•	Optional: Artikel-Override (z. B. „Hackfleisch: 90 Tage“) oder Kategorie-Defaults (Gemüse 365, Fleisch 180, Brot 90).
	•	Beim Einlagern (+1) berechnet die App automatisch MHD = today + defaultDays.
	•	Gleiches MHD am selben Tag? → gleiche Charge (Batch) wird erhöht.
	•	Anderes MHD? → neue Charge automatisch.

Mini-Korrektur ohne Tippen (falls nötig)

Im Dialog-Modus zeigen wir drei Quick-Tasten:
	•	±7 Tage, +30 Tage, Monatsende
und einen Button „Heute als Produktionsdatum“ (falls du Ware am Folgetag einsortierst – rechnet rückwärts neu). Das ist 1–2 Taps, kein Tippen.

Datenmodell (ergänzt)
	•	items: { id, name?, defaultDays? , category? , locationId? }
	•	batches: { batchId, itemId, expDate (ISO), qty }
	•	stock bleibt optional (Summe der Batches).

Workflow in den Modi
	•	Auto +1: Scan → Item auto-anlegen (falls neu) → ensureBatchFor(item, today + defaultDays) → qty++.
	•	Auto −1: Scan → FEFO (First-Expire-First-Out): nimm Menge aus der frühesten Charge.
	•	Dialog: wie oben, plus Menge und Quick-MHD-Tasten.

UI-Einstellungen (1x konfigurieren)
	•	„Standard-MHD (Tage)“ global.
	•	Optional: pro Artikel „Standard-MHD überschreiben“.
	•	Schalter: „FEFO bei Entnahme“ (an).
	•	Warnungen: bald fällig (z. B. ≤14 Tage), abgelaufen (rot).

⸻

Drop-in-Code (Auszug, Vanilla JS)

Helfer für MHD-Berechnung

function addDays(date, days){
  const d = new Date(date); d.setDate(d.getDate()+days); 
  d.setHours(0,0,0,0); return d;
}
function endOfMonth(date){
  const d = new Date(date); d.setMonth(d.getMonth()+1, 0);
  d.setHours(0,0,0,0); return d;
}
function iso(d){ return new Date(d).toISOString().slice(0,10); } // YYYY-MM-DD

Default-Tage ermitteln

const settings = { defaultDays: 180 }; // global, per UI änderbar

async function getDefaultDays(item){
  if (item?.defaultDays) return item.defaultDays;
  // optional: per Kategorie verfeinern
  // if (item?.category === "Gemüse") return 365;
  return settings.defaultDays;
}

Charge (Batch) finden/erzeugen

// batches-Store nach itemId indexieren; hier vereinfachte Variante mit localForage-Instanz dbBatches
async function ensureBatchFor(itemId, expDateISO){
  let found=null;
  await dbBatches.iterate(b=>{
    if (b.itemId===itemId && b.expDate===expDateISO) found=b;
  });
  if (found) return found;
  const batch = { batchId: crypto.randomUUID(), itemId, expDate: expDateISO, qty: 0 };
  await dbBatches.setItem(batch.batchId, batch);
  return batch;
}

Einlagern (mit Standard-MHD)

async function storePlusOne(itemId, baseDate = new Date()){
  const item = await upsertItem({ barcode:itemId }); // aus deinem Beispiel
  const days = await getDefaultDays(item);
  const exp = iso(addDays(baseDate, days));
  const batch = await ensureBatchFor(itemId, exp);
  batch.qty += 1;
  await dbBatches.setItem(batch.batchId, batch);
  await render();
  flash("green");
}

Entnehmen (FEFO)

async function consumeMinusOne(itemId){
  const batches = [];
  await dbBatches.iterate(b=>{ if (b.itemId===itemId) batches.push(b); });
  if (!batches.length) return beepError("Kein Bestand");
  batches.sort((a,b)=> a.expDate.localeCompare(b.expDate)); // frühestes zuerst
  for (const b of batches){
    if (b.qty>0){ b.qty -= 1; await dbBatches.setItem(b.batchId,b); break; }
  }
  await render();
  flash("red");
}

Dialog-Quick-Tasten (ohne Tippen)

let overlayState = { itemId:null, baseDate: new Date(), delta: 0 };

function overlayFor(id){
  overlayState = { itemId:id, baseDate:new Date(), delta:0 };
  // UI zeigt exp = today + defaultDays
}
function overlayAdjustDays(n){
  overlayState.baseDate = addDays(overlayState.baseDate, n);
  // UI exp neu berechnen & anzeigen
}
function overlaySetMonthEnd(){
  overlayState.baseDate = endOfMonth(new Date());
}
async function overlayConfirm(){
  const { itemId, baseDate, delta } = overlayState;
  if (delta===0) return; // nichts zu tun
  const sign = Math.sign(delta);
  const times = Math.abs(delta);
  for (let i=0;i<times;i++){
    if (sign>0) await storePlusOne(itemId, baseDate);
    else await consumeMinusOne(itemId);
  }
  closeOverlay();
}

Auto-Modi anbinden

let mode = "autoPlus"; // "autoPlus" | "autoMinus" | "dialog"

async function onScan(itemId){
  await ensureItem(itemId);
  if (mode==="autoPlus")  return storePlusOne(itemId);
  if (mode==="autoMinus") return consumeMinusOne(itemId);
  overlayFor(itemId); // Dialog
}


⸻

Listen & Druck
	•	FEFO-Pickliste: sortiere batches nach expDate → zeige „heute/7/14 Tage fällig“.
	•	Etikettendruck: QR + „MHD: 2026-03-14“ mitdrucken (bei Nachdruck oder Erstetikett).
(Mit JsBarcode/QRCode wie im vorherigen Beispiel – nur die MHD-Zeile ergänzen.)

⸻

Gute Defaults (du kannst später feinjustieren)
	•	Global: TK 180 Tage.
	•	Gemüse/Obst: 365 Tage (TK).
	•	Brot/Backwaren: 90 Tage.
	•	Gekochtes/Resteboxen: 120 Tage.
Du kannst das zunächst nur global starten (am simpelsten). Wenn’s sitzt, ergänzen wir pro Artikel eine eigene Zahl.

⸻

Wenn du möchtest, baue ich dir den vorhandenen Prototypen direkt mit:
	•	Auto ±1 / Dialog
	•	Batches mit MHD
	•	FEFO-Entnahme
	•	Quick-Tasten ±7 / +30 / Monatsende

Sag mir nur: Starten wir mit nur einem globalen Wert (z. B. 180) – und feiner später?

👉



100% d’accord – wenn’s nicht in 1–2 Handgriffen geht, nutzt es keiner. Lass uns den Workflow radikal auf „scannen, piep, fertig“ trimmen. Hier ist ein Setup, das in der Praxis wirklich schnell ist – ohne Tippen, ohne Menüs.

Der ultraschnelle Standard-Workflow

Physische Bausteine
	1.	Artikel-Sticker (QR)
– Vorab A4-Bögen mit zufälligen IDs drucken (z. B. ITM:01H…).
– Auf jedem Sticker zusätzlich: Kurz-ID (z. B. letzte 5 Zeichen) + kleine MHD-Zeile zum handschriftlichen Datum.
– Beim Einfrieren: Sticker drauf – fertig.
	2.	Aktions-Pad (QR) – laminiert an/ in die Truhe:

	•	„+1 Einlagern“ → ADD:
	•	„−1 Entnehmen“ → USE:
	•	Mengen-Modifier: ×2, ×3, ×5 → SETQTY:+2 (als Zusatz) oder „zweimal scannen“
	•	Orte (Fächer): SETLOC:TK-A1, TK-A2, …
	•	UNDO (letzte Aktion rückgängig)

Du scannst immer nur große Kachel + Item-Sticker. Keine Tastatur, kein Suchen.

App-Logik (super simpel)
	•	Die App merkt sich zwei Dinge: letzte Aktion & letzte Item-ID.
	•	Reihenfolge egal:
	•	Scannst du „+1“ und dann Item → Bestand +1.
	•	Scannst du Item und dann „−1“ → Bestand −1.
	•	Modifier/Ort kannst du davor oder danach scannen:
	•	×3 + Item = drei Stück in einem Rutsch.
	•	SETLOC:TK-A1 + Item = Ort gesetzt.
	•	Feedback: großer Farbflash (grün/rot), kurzer Ton, Haptik (iPhone).
	•	UNDO: Scan „UNDO“ → letzte Buchung rückgängig, fertig.

Tägliche Nutzung
	•	Einlagern (2 Scans): +1 → Item-QR. Piep.
	•	Entnehmen (2 Scans): −1 → Item-QR. Piep.
	•	Mehrere gleiche Items (Batch): Batch +1 (Knopf in der App) aktiv → nur Item-QR n-mal scannen, jedes Mal piep.
	•	Ort zuweisen: SETLOC:TK-A1 → Item-QR (oder im Batch einmal Ort scannen, gilt für alle folgenden Scans bis geändert).

Warum das schnell bleibt
	•	Null Tippen (Namen optional/selten).
	•	Zwei Scans max. pro Aktion – oft sogar einer im Batch.
	•	Große, feste Ziel-QRs (Aktionen) kleben in Griffweite.
	•	Item-QRs sind klein, aber robust (QR statt EAN).
	•	Fehlertolerant: Reihenfolge egal, UNDO da.

Details, die es in der Praxis retten
	•	Stickergröße: QR-Kantenlänge ~20–24 mm; darunter Kleintext: „Kurz-ID 7XQ9F | MHD: ____“.
	•	Material: gefrierfeste PP/Polyester-Etiketten, starker Gefrierkleber.
	•	Visuelles System: Fächer farbcodiert (A-F) + zugehörige SETLOC-QRs in derselben Farbe → Gehirn schaltet auf Autopilot.
	•	Akustik: anderes Piep für +/−, langer Ton bei Fehler, kurzer Doppel-Piep bei Batch-Modus.
	•	„Lieblingsartikel“ (optional): Erstes Mal, wenn eine neue ID auftaucht, tippst du EINMAL auf einen großen Favoriten-Chip („Erbsen“, „Beeren“, „Bolo“). Danach nie mehr. Fehlt dir das komplett? Lass es weg – Namen sind nett, aber nicht nötig fürs Zählen.

Drei Nutzungsstufen (du entscheidest)
	1.	„Zählen reicht“ (Default)
– Nur IDs, Mengen, Orte. Kein Tippen, nur Scans.
	2.	„Leichte Namen“
– Optional 6–8 Favoriten als große Chips; 1-Tap beim ersten Mal.
	3.	„Detailmodus (selten)“
– Pro Charge MHD oder Notiz tippen – nur wenn du magst (z. B. für Resteverwaltung).

Sonderfälle sauber gelöst
	•	Kein Sticker mehr? Scanne ADD: → App zeigt „Neue ID generiert“ → tippe 1× „Drucken“ (falls BT-Drucker nebenan) oder klebe einen vorproduzierten Reserve-Sticker.
	•	Sticker beschädigt? Kurz-ID eintippen oder Übersicht öffnen und per Kamera-Suche das Item finden (Sekundenarbeit).
	•	Duplizierte IDs (versehentlich 2× gleiches Label genutzt)? App meldet’s, bietet „mit bestehendem Artikel zusammenführen“.

UI in 5 großen Flächen (Daumen-Bedienung)
	•	Oben Vollbild-Scanner (immer aktiv).
	•	Darunter Aktions-Leiste: „+1“, „−1“, „Batch“, „UNDO“.
	•	Ort-Chips (deine 6–10 Fächer).
	•	Mengen-Chips: ×2 / ×3 / ×5.
	•	Footer: Bestand-Kacheln (nur lesen), große Suchleiste (optional).

Physisches Setup (entscheidet über Erfolg)
	•	Aktions-Pad direkt an die Truhe (Innen-Deckel).
	•	BT-Drucker (wenn genutzt) direkt daneben auf einem kleinen Regal.
	•	Etiketten-Bögen griffbereit in einer Klarsichthülle an der Truhe.
	•	Filzstift (MHD) hängt an der Truhe.

Messbar machen (damit wir merken, ob’s wirklich easy ist)
	•	Zielwerte:
	•	Einlagern: ≤ 3 Sek. pro Artikel (2 Scans).
	•	Entnehmen: ≤ 2 Sek. pro Artikel (2 Scans).
	•	Fehlerrate: < 1% (UNDO fängt auf).
	•	In der App: simple Counter „heute gespeichert/entnommen“ + „Zeit pro Vorgang“.

⸻

Wenn du willst, setze ich dir genau diese drei Dinge direkt um:
	1.	A4-Bogen: 80 vorproduzierte Item-QR-Sticker (mit Kurz-ID & MHD-Zeile).
	2.	A4-Aktions-Pad: +1, −1, ×2/×3/×5, UNDO, SETLOC für deine Fächer.
	3.	App-Einstellung: „Zwei-Scan-Logik“, Batch-Modus, UNDO, farbiges Feedback.

Sag mir nur kurz deine Fach-Bezeichnungen (z. B. TK-A1…A4, TK-B1…B4) und ob du Namen/Favoriten überhaupt willst – ansonsten baue ich es im „Zählen reicht“-Modus, der ist am schnellsten.

ultraschnell & simpel

Drei Modi (umschaltbar oben in der App):
	1.	Auto +1 – Jeder Scan zählt sofort +1. (Für Einfrieren – zack zack.)
	2.	Auto −1 – Jeder Scan zählt sofort −1. (Für Entnahmen.)
	3.	Dialog – Scan → kleines Overlay mit +1, −1, Ziffernfeld → OK.

Warum kein „×-Multiplikator-QR“?
Brauchen wir nicht. Deine IDs sind zufällig; Multiplizieren per „×3“-QR war nur für die Zwei-Scan-Variante sinnvoll. Hier reicht im Dialog die Zahl einzugeben – oder du bleibst in Auto-+1 und scannst denselben Sticker n-mal (sehr schnell).

Quality-of-life:
	•	UNDO: großer Button, macht den letzten Scan rückgängig.
	•	Unknown ID → auto-anlegen (nur ID + optional Ort; Name später).
	•	Haptik/Ton/Farbflash: + grün, − rot, Fehler gelb.
	•	„Sticky-Ort“ (optional): einmal Ort wählen → gilt, bis du’s änderst.
	•	Timeout: Dialog schließt nach 2–3 s automatisch; Modus bleibt.

⸻

Logik (knackig)

let mode = "autoPlus"; // "autoPlus" | "autoMinus" | "dialog"

async function onScan(id){         // id ist z.B. "ITM:01H…"
  await ensureItem(id);            // auto-anlegen falls neu
  if (mode === "autoPlus")  return move(id, +1), flash("green");
  if (mode === "autoMinus") return move(id, -1), flash("red");
  openOverlay(id);                 // Dialog: +1 / -1 / Zahl -> OK
}

async function overlayConfirm(id, delta){ // delta kann ±1 oder ±N sein
  await move(id, delta);
  flash(delta>0 ? "green" : "red");
}

function undoLast(){ /* letzte move rückgängig machen */ }


⸻

Bedienung in der Praxis
	•	Einfrieren (Serien): Modus Auto +1, jeden Sticker einmal scannen → piep, fertig.
	•	Entnehmen: Modus Auto −1, einmal scannen → piep, fertig.
	•	Sondermengen: Modus Dialog, scannen → Zahl tippen → OK.

Das ist wirklich „Scan → piep → weiter“. Keine Aktions-QRs, keine Menüs.

⸻

Nächste kleine Extras (wenn du magst)
	•	„Doppeltipp = ±5“ auf dem Plus/Minus im Dialog.
	•	MHD-Hinweis: nach erstem +1 auf neue ID optional Datum eintippen (oder ignorieren).
	•	Schnellfilter: „unter Minimum“, „bald fällig“, „nach Ort“ – nur lesen, kein Tippen nötig.

Wenn du willst, passe ich dir den Beispielcode direkt auf diese drei Modi + Overlay + UNDO an – dann kannst du ihn sofort im Browser testen (PWA, offline, iPhone-Kamera ready).



Absolut – “Scan → ggf. kurz benennen → weiter” + Repeat-Modus ist genau der Sweet-Spot. Hier ist ein schlanker, praxistauglicher Plan inkl. Drop-in-Logik:

Ziel
	•	Nach dem Scan nur dann editieren, wenn nötig (neu/unnütz benannt).
	•	Edit-Overlay: 3–5 Felder, große Buttons, in 5–10 Sek. erledigt.
	•	Repeat-Modus: „Vorherige Eingaben vorausfüllen“ für Serien (z. B. viele Beutel Bolognese).

⸻

UX-Flow
	1.	Scan
	•	Wenn neu ODER Name fehlt → Edit-Overlay öffnen.
	•	Wenn bekannt → normaler Turbo-Modus (Auto ±1 / Dialog).
	2.	Edit-Overlay (Daumen-freundlich)
Felder (in dieser Reihenfolge):
	•	Name (Pflicht, Autovervollständigung aus “zuletzt verwendet”)
	•	Kategorie (Chips: Gemüse, Fleisch, Reste, Brot, …) → setzt optional Default-MHD
	•	Ort (Chips: TK-A1, TK-A2, …)
	•	Standard-MHD (Tage) (kleiner Spinner; vorausgefüllt aus global/kategorie)
	•	Notiz (optional, 1 Zeile)
Buttons unten: [Speichern] [Abbrechen] [Label drucken]
Option rechts oben: Repeat ON/OFF (Schalter).
	3.	Repeat-Modus
	•	Wenn ON: Beim nächsten neuen Scan sind Name/Kategorie/Ort/Default-MHD vorausgefüllt (aus „Last Template“) – nur noch Speichern tippen (oder gleich Auto +1 ohne Edit, je nach Modus).
	•	Wenn OFF: Normales Verhalten.
	4.	Schnellzugriffe
	•	Langer Druck auf „Letzter Artikel“-Badge (am unteren Rand) → Edit-Overlay mit den letzten Werten öffnen.
	•	Doppeltipp im Dialog-Modus auf den Artikelnamen → sofort Edit-Overlay.

⸻

Datenmodell (ergänzt)

Item {
  id: string;          // "ITM:…"
  name?: string;
  category?: string;   // z.B. "Fleisch"
  locationId?: string; // z.B. "TK-A1"
  defaultDays?: number; // Override
  notes?: string;
  createdAt: string;
  updatedAt: string;
}

Settings {
  defaultDays: number;       // global
  categoryDefaults: Record<string, number>; // optional
  repeatTemplate?: Partial<Item>; // zuletzt gespeichertes Template
  repeatOn: boolean;
}


⸻

Entscheidungslogik (wann Edit aufpoppt)

function shouldEditAfterScan(item, settings){
  if (!item) return true;               // neu → anlegen/benennen
  if (!item.name) return true;          // unbenannt → benennen
  // Optional: Shortcut-Taste „Edit erzwungen“ (z. B. Taste E)
  return false;
}


⸻

Drop-in-Code (Auszüge, Vanilla JS)

Zentrales Scan-Handling

let settings = {
  defaultDays: 180,
  categoryDefaults: { Gemüse: 365, Fleisch: 180, Brot: 90, Reste: 120 },
  repeatOn: false,
  repeatTemplate: null
};

async function onScan(itemId){
  let item = await dbItems.getItem(itemId);
  if (!item) {
    // Neu anlegen (minimal)
    item = { id: itemId, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
    // Repeat-Template anwenden, falls aktiv
    if (settings.repeatOn && settings.repeatTemplate) {
      Object.assign(item, settings.repeatTemplate);
    }
    await dbItems.setItem(itemId, item);
  }
  if (shouldEditAfterScan(item, settings)) {
    openEditOverlay(item);  // → siehe unten
  } else {
    // Sonst normaler Turbo-Modus
    if (mode === "autoPlus")  return storePlusOne(itemId);
    if (mode === "autoMinus") return consumeMinusOne(itemId);
    openDialogOverlay(itemId);
  }
}

Edit-Overlay öffnen & vorausfüllen

function computeDefaultDaysFor(item){
  if (Number.isFinite(item.defaultDays)) return item.defaultDays;
  if (item.category && Number.isFinite(settings.categoryDefaults[item.category])) {
    return settings.categoryDefaults[item.category];
  }
  return settings.defaultDays;
}

function openEditOverlay(item){
  const el = document.getElementById('editOverlay');
  // Felder setzen
  el.querySelector('#f_name').value      = item.name || settings?.repeatTemplate?.name || '';
  el.querySelector('#f_category').value  = item.category || settings?.repeatTemplate?.category || '';
  el.querySelector('#f_location').value  = item.locationId || settings?.repeatTemplate?.locationId || '';
  el.querySelector('#f_days').value      = computeDefaultDaysFor(item);
  el.querySelector('#f_notes').value     = item.notes || '';
  el.querySelector('#repeatToggle').checked = !!settings.repeatOn;

  el.dataset.itemId = item.id;
  el.style.display = 'block';
}

Speichern + Template aktualisieren

async function saveEdit(){
  const el = document.getElementById('editOverlay');
  const id  = el.dataset.itemId;

  const updated = {
    id,
    name:       el.querySelector('#f_name').value.trim(),
    category:   el.querySelector('#f_category').value.trim() || undefined,
    locationId: el.querySelector('#f_location').value.trim() || undefined,
    defaultDays: parseInt(el.querySelector('#f_days').value, 10),
    notes:      el.querySelector('#f_notes').value.trim() || undefined,
    updatedAt:  new Date().toISOString()
  };

  const existing = await dbItems.getItem(id) || { id, createdAt: new Date().toISOString() };
  const merged = { ...existing, ...updated };
  await dbItems.setItem(id, merged);

  // Repeat-Schalter übernehmen & Template aktualisieren
  settings.repeatOn = el.querySelector('#repeatToggle').checked;
  if (settings.repeatOn) {
    settings.repeatTemplate = {
      name: merged.name,
      category: merged.category,
      locationId: merged.locationId,
      defaultDays: merged.defaultDays
    };
    await dbSettings.setItem('repeatTemplate', settings.repeatTemplate);
    await dbSettings.setItem('repeatOn', true);
  } else {
    settings.repeatTemplate = null;
    await dbSettings.setItem('repeatOn', false);
  }

  // optional: direkt Label drucken?
  // printLabel(merged); // falls Button gedrückt wurde

  closeEditOverlay();
  render(); // Tabelle aktualisieren
}

UI-Schnipsel (Overlay-HTML minimal)

<div id="editOverlay" style="display:none; position:fixed; inset:0; background:#0008;">
  <div style="margin:10vh auto; max-width:520px; background:#fff; padding:16px; border-radius:12px;">
    <h3>Artikel bearbeiten</h3>
    <label>Name <input id="f_name" placeholder="z.B. Bolognese" autofocus></label>
    <label>Kategorie 
      <select id="f_category">
        <option value="">–</option>
        <option>Gemüse</option><option>Fleisch</option><option>Brot</option><option>Reste</option>
      </select>
    </label>
    <label>Ort 
      <select id="f_location"><option>TK-A1</option><option>TK-A2</option><option>TK-B1</option><option>TK-B2</option></select>
    </label>
    <label>Standard-MHD (Tage) <input id="f_days" type="number" min="1" step="1"></label>
    <label>Notiz <input id="f_notes" placeholder="optional"></label>
    <div style="display:flex;align-items:center;gap:.5rem;margin:.5rem 0;">
      <input id="repeatToggle" type="checkbox"> <label for="repeatToggle">Repeat-Modus</label>
    </div>
    <div style="display:flex; gap:.5rem; justify-content:flex-end;">
      <button onclick="closeEditOverlay()">Abbrechen</button>
      <button onclick="saveEdit()">Speichern</button>
      <button onclick="saveEdit(); printLabelById(this.closest('#editOverlay').dataset.itemId)">Label drucken</button>
    </div>
  </div>
</div>

„Letzten Artikel“ schnell wiederverwenden

let lastScannedId = null;

async function onScan(itemId){
  lastScannedId = itemId;
  // ... (wie oben)
}

function editLast(){
  if (!lastScannedId) return;
  dbItems.getItem(lastScannedId).then(openEditOverlay);
}
// UI: ein kleiner „Stift“-Button neben „zuletzt gescannt: …“


⸻

Feinschliff (macht’s spürbar besser)
	•	Fokus nach Öffnen direkt in „Name“, Enter = Speichern.

Praxis-Beispiel
	•	Du kochst 10 x Bolo → Repeat ON, einmal „Bolognese / Reste / TK-A2 / 120 Tage“ speichern → danach nur scannen (Auto +1) – kein weiteres Tippen.
	•	Neues Produkt „Erbsen“ → erster Scan öffnet Edit → Name/Kategorie/Ort setzen → fertig; danach nur noch scannen.


dir fehlt nur Ort, Status und (für Komfort) Defaults/Verlauf.
Du hast: Bestand, Beschreibung (Name), ID (+ Kurz-ID ableitbar), Einlagerdatum, MHD. Das reicht knapp – aber zwei Dinge entscheiden die Alltagstauglichkeit:

Erst entscheiden: 1 Sticker = 1 Packung (empfohlen)

Dann brauchst du keine Mengenfelder – der Bestand ist einfach die Anzahl Datensätze.

Minimal-Schema (wirklich schlank & ausreichend)
	•	id (Lang-ID im QR)
	•	shortId (abgeleitet, z. B. letzte 5 Zeichen)
	•	name (Artikelbeschreibung)
	•	location (Fach/Box, z. B. „TK-A2“) ← fehlt noch
	•	inDate (Einlagerdatum)
	•	expDate (MHD)
	•	status ("in_stock"/"used") ← fehlt für Entnahmen/UNDO
	•	notes (optional, 1 Zeile)

Bestand = count(where status="in_stock").
Vorteil: Scannen = neuer Datensatz, Entnahme = Status auf „used“. Super robust, null Summenlogik.

Alternative: 1 ID = Artikel (SKU) mit Menge

Dann brauchst du Mengen & Chargen:
	•	item (SKU) + qty (aktuelle Menge)
	•	batches[{expDate, qty}] (für MHD/FEFO)
	•	moves[{timestamp, delta}] (Verlauf für UNDO)

Das ist flexibler, aber komplexer. Für deinen „Scan-Piep-Fertig“-Ansatz ist 1 Sticker = 1 Packung einfacher.

Zwei kleine Ergänzungen, die es spürbar besser machen
	•	Defaults: defaultDays (global oder per Kategorie) → MHD wird automatisch gerechnet.
	•	Verlauf (leicht): lastMove (Zeit+Aktion) → UNDO ohne Kopfzerbrechen.

Fazit
	•	Mit 1 Sticker = 1 Packung ist dein Set mit Ort + Status vollständig und alltagstauglich.
	•	Wenn du stattdessen mit Mengen arbeiten willst, brauchst du Chargen + Moves dazu.

Sag mir, welche Variante du nimmst – ich passe dir den Prototyp (Felder/UI) direkt darauf an.
